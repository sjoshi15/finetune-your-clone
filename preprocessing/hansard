
from tqdm.auto import tqdm
from whatsapp.load_whatsapp import encoder, HISTORY_MAX_TOKENS, CONVO_MIN_TOKENS
import pandas as pd
import json

def collapse_messages(data):
    new_data = []
    
    current_role = data[0]["speaker"]
    current_message = data[0]["text"]
    current_title = data[0]["title"]
    
    for row in tqdm(data[1:]):
        row_role = row["speaker"].strip()
        row_message = row["text"].strip()
        row_title = row["title"].strip()

        if row_role == current_role or row_role in current_role and row_title == current_title:
            current_message += "\n" + row_message
        else:
            new_data.append({"role": current_role, "text": current_message, "title": current_title})
            current_message = row_message
            current_role = row_role
            current_title = row_title
    
    # add last row
    new_data.append({"role": current_role, "text": current_message, "title": current_title})

    return new_data


def preprocess_convo(input_path, output_path):
    with open(input_path, 'r') as f:
        lines = f.readlines()
    
    lines = [json.loads(l) for l in lines]

    data = collapse_messages(lines)

    query = []
    conversation = []
    token_len = 0


    for row in tqdm(data):
        row_role = row["role"]
        row_message = row["text"]
        row_title = row["title"]

        chat_message_formatted = "<start_header_id>{role}<end_header_id>{message}".format(role=row_role, message=row_message)
        chat_message_formatted_len = len(encoder.encode(chat_message_formatted))
      
        # Add message to conversation if it's within one hour from the previous message, and the history is less than 5000 tokens
        if token_len + chat_message_formatted_len<HISTORY_MAX_TOKENS: 
            conversation.append(chat_message_formatted)
        
        # If message is more than one hour from the previous one or history length is too long, create a new conversation to hold the current message
        else:
            # Write the current conversation to the final query
            query.append(conversation)
            # reset
            conversation = [chat_message_formatted]
            token_len = chat_message_formatted_len

    # write out the last conversation
    query.append(conversation)


    df_model = pd.DataFrame({"query": query})
    df_model['query_str'] = df_model['query'].apply(lambda x: "<|eot_id|>".join(x))
    df_model['query_len'] = df_model['query_str'].apply(lambda x: len(encoder.encode(x)))
    
    # remove short conversations
    df_model_filtered = df_model[df_model['query_len'] > CONVO_MIN_TOKENS]


    # write output as json lines in the format {'input': formatted_message} so that we can use it for finetuning
    with open(output_path, 'w') as f:
        for _, row in df_model_filtered.iterrows():
            f.write(json.dumps({'input': row['query_str']}) + '\n')    
